<?xml version="1.0" encoding="UTF-8"?>
<article xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="../../../../../docs.xsd"
         id="concurrency-support">
   <title>Concurrency Support</title>
   <description>TODO: Add description.</description>
   <introduction>
      <paragraph>The Couchbase Lite API is mostly synchronous. That makes it simpler and more efficient. Most of the API calls are quick enough that it's not a problem to run them on the main thread, but some things might become too slow, especially with large databases, so you might want to offload the processing to a background thread. You have a couple of options.</paragraph>
   </introduction>
   <topics>
      <topic id="asynchronous-queries">
         <title>Asynchronous Queries</title>
         <body>
            <paragraph>View queries slow down as the database grows, especially when the view's index needs to be updated after the database changes. You can prevent this from blocking your UI by running the query asynchronously.</paragraph>
            <paragraph>The easiest way to do this is just to use <code>LiveQuery</code>. It always runs its queries in the background, and then posts a notification on the main thread after the query is complete.</paragraph>
            <paragraph>If you use a regular <code>Query</code> object directly, though, you might find that calling the  synchronous <code>run()</code> method getting slow. You can access the result rows asynchronously like this:</paragraph>
            <code-block>
Future future = query.runAsync(new Query.QueryCompleteListener() {
        @Override
        public void completed(QueryEnumerator rows, Throwable error) {
            // operate on row...
        }
    });
</code-block>
            <paragraph>The <code>runAsync()</code> method returns immediately, but performs the query on a background thread. When the query finishes, your callback is called with the query result as its parameter.</paragraph>
            <paragraph>Error checking is a bit different. In synchronous mode <code>query.run()</code> throws an exception if there is an error. The async API will call your callback with a <code>Throwable</code> in the case when there was an error during the query.</paragraph>
         </body>
      </topic>
      <topic id="general-purpose-asynchronous-calls">
         <title>General-purpose asynchronous calls</title>
         <body>
            <paragraph>Also, there’s a more general-purpose method for doing asynchronous operations, which a few people have asked for. You can now use the <code>Manager</code> object to perform any operation in the background. Here’s an example that deletes a bunch of documents given an array of IDs:</paragraph>
            <code-block>

final String[] docids = new String[] {"id1", "id2", "id3"};

Future result = manager.runAsync("db", new AsyncTask() {
    @Override
    public boolean run(Database database) {
        for (String docid : docids) {
            database.getDocument(docid).delete();
        }
        return true;
    }
});
</code-block>
         </body>
      </topic>
   </topics>
</article>
