<?xml version="1.0" encoding="UTF-8"?>
<article xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../docs.xsd" id="view">
    <title>View</title>
    <description>Guide to map/reduce views.</description>
    <introduction>
        <paragraph>
            A View is a persistent index of documents in a database, which you then query to find data. Couchbase Lite doesn't have a query language like SQL; instead, it uses a technique called <strong><ref href="http://en.wikipedia.org/wiki/Map-reduce">map/reduce</ref></strong> to generate indexes (views) according to arbitrary app-defined criteria. Queries can then look up a range of rows from a view, and either use the rows' keys and values directly or get the documents they came from.
        </paragraph>
        <paragraph>
            The main component of a view (other than its name) is its <strong>map function</strong>. This function is written in the same language as your app—most likely Objective-C or Java—so it’s very flexible. It takes a document's JSON as input, and outputs any number of key/value pairs to be indexed. The view generates a complete index by calling the view function on every document in the database, and adding each key/value pair to the index, sorted by key. For example, a map function might grind through an address-book database and produce a set of mappings from names to phone numbers. The index is persistent, and updated incrementally as documents change. (It’s very much like the type of index a SQL database creates internally to optimize queries.)
        </paragraph>
        <paragraph>
            A view may also have a <strong>reduce function</strong>. If present, it can be used during queries to combine multiple rows into one. It can be used to compute aggregate values like totals or averages, or to group rows by common criteria (like collecting all the artists in a record collection.)
        </paragraph>
        <paragraph>
            Remember: <strong>a view is not a query, it’s an index.</strong> Views are persistent, and need to be updated (incrementally) whenever documents change, so having large numbers of them can be expensive. Instead, it’s better to have a smaller number of views that can be queried in interesting ways.
        </paragraph>
    </introduction>
    <topics>
        <topic id="creating">
            <title>Creating and initializing views</title>
            <body>
                <paragraph><code>View</code> objects belong to a <code>Database</code>. You create or find a view by calling the database's <code>viewNamed</code> method, which will create and return a new View if none exists by that name.
                </paragraph>
                <paragraph>
                    Even though a view is persistent, its map and reduce functions aren't: they're just function pointers (or blocks, or inner classes) and have to be registered at runtime, before the view is queried. It's good practice to set up views when your app starts up, right after opening the database:
                </paragraph>
                <code-set>
                    <code-block language="objective-c"><![CDATA[
                        // Create a view and register its map function:
                        CBLView* phoneView = [db viewNamed: @"phones"];
                        [view setMapBlock: MAPBLOCK({
                            for (NSString* phone in doc[@"phones"]) {
                                emit(phone, doc[@"name"]);
                            }
                        }) version: @"2"];
                    ]]></code-block>
                </code-set>
                <paragraph>
                    The <code>version</code> parameter to <code>setMapBlock</code> takes a bit of explanation. During development, and as you update the app, you may change the behavior of a map function. This invalidates any existing index generated by that function, so the next time the app runs, the view should rebuild the index from scratch using the new function. Unfortunately the view can't tell that the map function is different because it can't see its source code! Instead, you have to provide a version string that it <emphasis>can</emphasis> compare, and change that string whenever you change the function. The easiest thing to remember is just to set the version to <code>"1"</code> initially, and then increment it every time you change the map function (or anything it calls that its output depends on.)
                </paragraph>
            </body>
        </topic>

        <topic id="querying">
            <title>Querying views</title>
            <body>
                <paragraph>
                    You query a view by using a <code>Query</code> object that you create from a <code>View</code> by calling <code>createQuery</code>. This is covered in a separate article on the Query class.
                </paragraph>
            </body>
        </topic>

        <topic id="mapfunctions">
            <title>Understanding map functions</title>
            <body>
                <paragraph>
                    As discussed in the introduction, a map function's job is to look at a document's JSON contents and from them produce (emit) zero or more key/value pairs to be indexed. If you know SQL, you can think of it as corresponding to the expressions that immediately follow the <code>SELECT</code> and <code>WHERE</code> keywords, only more powerful because you have the full power of a programming language available.
                </paragraph>
                <paragraph>
                    For discussion purposes, here's a simple map function in JavaScript:
                </paragraph>
                <code-set>
                    <code-block language="javascript"><![CDATA[
                        function(doc) {
                            if (doc["type"] == "person")
                                emit(doc["name"], doc["phone"]);
                        }
                    ]]></code-block>
                </code-set>
                <paragraph>
                    This function works with a database that contains, among other things, documents representing people, which are tagged with a <code>type</code> property whose value is <code>"person"</code>. (This use of a <code>type</code> property is a common idiom.) Every person document contains <code>name</code> and <code>phone</code> properties. The map function simply checks whether the document represents a person, and if it does, it calls <code>emit</code> to add the name and phone number to the index.
                </paragraph>
                <paragraph>
                    The resulting index maps names to phone numbers. You can query it to look up someone by name and find their phone number. You can also query it to get ranges of names, in alphabetical order, which is <emphasis>very</emphasis> useful for driving GUI list views.
                </paragraph>
            </body>
        </topic>
        <topic id="verboten">
            <title>Rules for the map function</title>
            <body>
                <paragraph>
                    The map function is called by the indexer to help generate an index, and it has to meet certain requirements, otherwise the index won't be consistent. It's important to understand some rules so you can create a proper map function, otherwise your queries can misbehave in strange ways.
                </paragraph>
                <unordered-list>
                    <list-item><strong>It must be a "<ref href="http://en.wikipedia.org/wiki/Pure_function">pure</ref>" function:</strong> That means any time it's called with the same input, it must produce <emphasis>exactly</emphasis> the same output. In other words, it can't use any external state, just its input JSON.</list-item>
                    <list-item><strong>It can't have side effects:</strong> It shouldn't change any external state, because it's unpredictable when it's called or how often it's called or in what order documents are passed to it.</list-item>
                    <list-item><strong>It must be thread-safe:</strong> It may be called on a background thread belonging to the indexer, or even in parallel on several threads at once.</list-item>
                </unordered-list>
                <paragraph>In particular, avoid these common mistakes:</paragraph>
                <unordered-list>
                    <list-item>Don't do anything that depends on the current date and time. That includes emitting a timestamp, emitting a person's age, or emitting only documents that have been modified in the past week.</list-item>
                    <list-item>Don't try to "parameterize" the map function by referring to an external variable whose value you change. People sometimes do this if they want to find various subsets of the data, like all the items of a particular color. Instead, emit all the values of that property and use a range request in the query to pick out the docs with a particular value.</list-item>
                    <list-item>Don't make any assumptions about when the map function is called. That's an implementation detail of the indexer. (For example, it's <emphasis>not</emphasis> called every time a document changes.)</list-item>
                    <list-item>Avoid having the map function call out into complex external code. That code might change later on to be stateful or have side effects, breaking your map function.</list-item>
                </unordered-list>
            </body>
        </topic>
        
        <topic id="keys">
            <title>Keys and values</title>
            <body>
                <paragraph>
                    Both the key and value passed to <code>emit</code> can be any JSON-compatible objects: not just strings, but also numbers, booleans, arrays, dictionaries/maps, and the special "null" object (which is distinct from a null pointer.) In addition, the value emitted, but <emphasis>not</emphasis> the key, can be a null pointer. (It's pretty common to not need a value in a view, in which case it's more efficient to not emit one.)
                </paragraph>
                <paragraph>
                    Keys are commonly strings, but it turns out that arrays are a very useful type of key as well. This is because of the way arrays are sorted: given two array keys, the first items are compared first, then if those match the second items are compared, and so on. That means that you can use array keys to establish multiple levels of sorting. If the map function emits keys of the form <emphasis>[lastname, firstname]</emphasis>, then the index will be sorted by last name, and entries with the same last name will be sorted by first name, just as if you'd used <code>ORDER BY lastname, firstname</code> in SQL.
                </paragraph>
                <paragraph>
                    Here are the exact rules for sorting (collation) of keys. The most significant factor is the key's object type; keys of one type always sort before or after keys of a different type. This list gives the types in order, and states how objects of that type are compared:
                </paragraph>
                <ordered-list>
                    <list-item><code>null</code></list-item>
                    <list-item><code>false, true</code> (in that order)</list-item>
                    <list-item>Numbers, in numeric order of course</list-item>
                    <list-item>Strings, case-insensitive. The exact ordering is specified by the <ref href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation Algorithm</ref>. This is <strong>not</strong> the same as ASCII ordering, so the results might surprise you -- for example, all symbols, including <code>"~"</code>, sort before alphanumeric characters.</list-item>
                    <list-item>Arrays, compared item-by-item as described above.</list-item>
                    <list-item>Maps/dictionaries, also compared item-by-item. Unfortunately the order of items is ambiguous (since JSON doesn't specify any ordering of keys, and most implementations use hash tables which randomize the order) so using these as keys isn't recommended.</list-item>
                </ordered-list>
            </body>
        </topic>
        
        <topic id="reduce">
            <title>Understanding reduce functions</title>
            <body>
                <paragraph>
                    TBD
                </paragraph>
            </body>
        </topic>
    </topics>
</article>
